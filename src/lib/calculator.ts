import { db } from './db';
import { UserCard, CardDefinition, RewardRule, RecommendationResult, RewardPart } from '@/types';
import cardDefinitions from '@/data/cards.json';

export const CARD_DEFS = cardDefinitions as CardDefinition[];

export function getCardDefinition(id: string): CardDefinition | undefined {
    return CARD_DEFS.find(c => c.id === id);
}

// --------------------------------------------------------------------------------
// Cycle Logic
// --------------------------------------------------------------------------------
export function getCycleRange(billingDay: number, period: "monthly" | "statement_cycle", targetDate: Date = new Date()) {
    const year = targetDate.getFullYear();
    const month = targetDate.getMonth(); // 0-indexed

    if (period === 'monthly') {
        // Calendar Month: 1st to last day
        const start = new Date(year, month, 1);
        const end = new Date(year, month + 1, 0, 23, 59, 59);
        return { start, end };
    } else {
        // Statement Cycle Logic (Simplified)
        // If billing day is 5th, cycle is approx previous 6th to this 5th.

        let startMonth = month;
        if (targetDate.getDate() < billingDay) {
            startMonth = month - 1;
        }

        // End Date is the billing day of the relevant month
        let closingDate = new Date(year, month, billingDay, 23, 59, 59);
        if (targetDate.getDate() > billingDay) {
            closingDate = new Date(year, month + 1, billingDay, 23, 59, 59);
        } else if (targetDate.getDate() < billingDay) {
            closingDate = new Date(year, month, billingDay, 23, 59, 59);
        }

        const prevClosing = new Date(closingDate);
        prevClosing.setMonth(prevClosing.getMonth() - 1);

        const startCycle = new Date(prevClosing);
        startCycle.setDate(startCycle.getDate() + 1);
        startCycle.setHours(0, 0, 0, 0);

        return { start: startCycle, end: closingDate };
    }
}

// --------------------------------------------------------------------------------
// Cap Calculation Logic
// --------------------------------------------------------------------------------

// Helper to get remaining cap for a specific Cap Group
async function getRemainingCap(
    userCard: UserCard,
    cardDef: CardDefinition,
    capGroupId: string,
    period: "monthly" | "statement_cycle"
): Promise<{ remaining: number, total: number }> {
    const capDef = cardDef.capDefinitions?.find(c => c.id === capGroupId);
    if (!capDef) return { remaining: Infinity, total: Infinity };

    // 1. Determine Time Range
    const { start, end } = getCycleRange(userCard.billingCycleDay, period);

    // 2. Fetch User's Transactions in this range
    const txs = await db.transactions
        .where('userCardId').equals(userCard.id)
        .filter(tx => tx.timestamp >= start.getTime() && tx.timestamp <= end.getTime())
        .toArray();

    // 3. Re-calculate usage
    // We need to sum up the REWARDS generated by parts linked to this capGroup.
    // This is tricky because we stored "earnedReward" (total) but not "partReward".
    // 
    // Heuristic: 
    // We assume the stored transactions followed the CURRENT current rules. 
    // We re-evaluate each transaction to see how much it would contribute to this cap.

    let usedCap = 0;

    for (const tx of txs) {
        // Find the rule that applies to this transaction's scenario
        // 1. Check schemes (Active scheme? We don't store historical active scheme...)
        // V1 Shortcut: Assume current active scheme or default rules.
        // Ideally Transaction should store `schemeId` or `capUsageBreakdown`.
        // Since we didn't store it, we'll try to match by scenario in current Default/Active rules.

        // Try simple Rules first
        let matchedRule = cardDef.rules.find(r => r.category === tx.scenario);
        if (!matchedRule) matchedRule = cardDef.rules.find(r => r.category === 'general');

        // If card has subSchemes, we might need to check them. 
        // But checking ALL schemes maximizes collision.
        // Let's assume Default Rules for cap calc if no scheme info.
        // (Improving this requires Schema Migration for Transaction).

        if (matchedRule) {
            // Calculate how much reward this part generated
            for (const part of matchedRule.rewardParts) {
                if (part.capGroupId === capGroupId) {
                    usedCap += tx.amount * (part.rate / 100);
                }
            }
        }
    }

    // 4. Return remaining
    return {
        remaining: Math.max(0, capDef.maxReward - usedCap),
        total: capDef.maxReward
    };
}


// --------------------------------------------------------------------------------
// Main Recommendation Logic
// --------------------------------------------------------------------------------
async function calculateRewardForRule(
    rule: RewardRule,
    userCard: UserCard,
    cardDef: CardDefinition,
    amount: number
) {
    let totalEstimatedReward = 0;
    const rateBreakdown = [];
    let ruleCapInfo = undefined;

    // A rule has multiple parts (e.g. Base + Bonus)
    // We calculate each part separately

    for (const part of rule.rewardParts) {
        let partReward = amount * (part.rate / 100);
        let appliedReward = partReward;
        let isCapped = false;
        let capInfo = undefined;

        // Check Cap if this part belongs to a group
        if (part.capGroupId) {
            const { remaining, total } = await getRemainingCap(userCard, cardDef, part.capGroupId, rule.period);

            if (partReward > remaining) {
                appliedReward = remaining;
                isCapped = true;
            }

            ruleCapInfo = { capGroupId: part.capGroupId, remaining, total };
        }

        totalEstimatedReward += appliedReward;

        rateBreakdown.push({
            rate: part.rate,
            note: part.note,
            isCapped
        });
    }

    // Warnings
    let warning = undefined;
    if (rateBreakdown.some(p => p.isCapped) || (ruleCapInfo && ruleCapInfo.remaining < 10)) {
        warning = "部分回饋已達或即將達上限";
    }

    return {
        effectiveReward: totalEstimatedReward,
        rateBreakdown,
        capInfo: ruleCapInfo ? [ruleCapInfo] : undefined,
        warning
    };
}

export async function calculateRecommendation(
    userCard: UserCard,
    scenario: string,
    amount: number
): Promise<RecommendationResult> {
    const cardDef = getCardDefinition(userCard.cardDefId);
    if (!cardDef) throw new Error("Card Def not found");

    // Strategy: Iterate schemes, find best
    const candidates = [];
    if (cardDef.subSchemes && cardDef.subSchemes.length > 0) {
        for (const s of cardDef.subSchemes) {
            candidates.push({ name: s.name, rules: s.rules });
        }
    } else {
        candidates.push({ name: undefined, rules: cardDef.rules });
    }

    let bestResult: RecommendationResult | null = null;

    for (const scheme of candidates) {
        let rule = scheme.rules.find(r => r.category === scenario);

        // Fallback: If specific travel country not found, try 'travel_overseas'
        if (!rule && ['travel_japan', 'travel_korea', 'travel_thailand'].includes(scenario)) {
            rule = scheme.rules.find(r => r.category === 'travel_overseas');
        }

        if (!rule) rule = scheme.rules.find(r => r.category === 'general');
        if (!rule) continue;

        const { effectiveReward, rateBreakdown, capInfo, warning } = await calculateRewardForRule(rule, userCard, cardDef, amount);
        const effectiveRate = (amount > 0) ? (effectiveReward / amount) * 100 : 0;

        // Use remainingCap of the first cap group found as a proxy for the simplified "Infinity" check in UI
        const simplisticRemaining = capInfo && capInfo.length > 0 ? capInfo[0].remaining : Infinity;

        const result: RecommendationResult = {
            userCard,
            cardDef,
            effectiveRate,
            estimatedReward: effectiveReward,

            capInfo,
            warningMessage: warning,
            schemeName: scheme.name,
            rateBreakdown
        };

        if (!bestResult || result.estimatedReward > bestResult.estimatedReward) {
            bestResult = result;
        }
    }

    if (!bestResult) {
        return {
            userCard, cardDef, effectiveRate: 0, estimatedReward: 0
        };
    }

    return bestResult;
}
